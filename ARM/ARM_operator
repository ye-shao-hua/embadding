---------------------------------------------------------------
#数据传送指令
MOV R1,#0X10          ;R1=0x10
MOV R0,R1             ;R0=R1
MOVS R3,R1,LSL #2     ;R3=R1<<2,并影响标志位
MOV PC,LR             ;PC=LR,子程序返回

#数据求反传送指令
MVN R1,#0xFF          ;R1=0xFFFFFF00
MVN R1,R2             ;将R2取反,结果存到R1

#算术，逻辑运算指令--------------------------------------------
#加法运算指令
ADD R1,R1,#1          ;R1=R1+x1 
ADD R2,R1,R2          ;R2=R1+R2
ADD R3,R1,R2,LSL #2   ;R3=R1+R2<<2

#减法运算指令
SUBS R0,R0,#1         ;R0=R0-1
SUBS R2,R1,R2         ;R2=R1-R2
SUB R6,R7.#0x10       ;R6=R7-0x10

#逆向减法指令
RSB R3,R1,#0xFF00     ;E3=0xFF00-R1
RSBS R1,R2,R2,LSL #2  ;R1=R2<<2-R2 
RSB R0,R1,#0          ;R0=-R1 

#32位乘法指令
MUL R1,R2,R3          ;R1=R2*R3
MULS RD,R3,R7         ;

#32位乘加指令
MLA R1,R2,R3,R0       ;R1=R2*R3+R0 

#逻辑指令-------------------------------------------------------
#逻辑与
ANDS R0,R0,#0x01      ;R0=R0&0x01 
AND R2,R1,R3          ;R2=R1&R3

#逻辑或
ORR R0,R0,#0x0F       ;R0=R0|#0x0F 

#逻辑异或
EOR R1,R1,#0x0F       ;将R1的低4位取反
EOR R2,R1,R0          ;R2=R1 xor R0 
EORS R0,R5,#0x01      ;将R5和0x01进行逻辑异或，将结果保存到R0，并影响标志位

#位清除指令
BIC R1,R1,#0x0F       ;将R1的低四位清除，其他位保持不变
BIC R1,R2,R3          ;将R3的反和R2相逻辑与，结果保存到R1 

#比较指令
CMP R1,#10            ;R1与10比较，设置相关标志位
CMP R1,R2             ;R1与R2比较，设置相关标志位

#复数比较指令
CMN R0,#1             ;判读那R0+1的结果是否为0；若是z置位（0标志），它实际上是判断R0是否为1的补码

#位测试指令
TST R0,#0x01          ;判断R0的最低位是否为0 
TST R1,#0x0F          ;判断R1的低4位是否为0 

#相等测试指令
TEQ R0,R1             ;比较R0与R1是否相等（不影响V位和C位）


#分支指令------------------------------------------------------
#跳转指令
B WAITA               ;跳转到WAITA标号处
B 0x1234              ;跳转到绝对地址0x1234处

#带链接的跳转指令
BL DELAY              

#带状态切换的跳转指令
BX R0 

#访存指令------------------------------------------------------
LDR R0,[R1,#8]        ;将存储器地址位R1+8的字读入R0
LDR R0,[R1]           ;R1寄存器对应地址的数据被取出放入R0
LDR R0,=NAME          ;R0寄存器将取NAME标号地址存放的数据
LDR R0,=0x123         ;R0寄存器将取0x123地址存放的数据
STR R1,[R0]           ;将R1中的数据存储到R0指向的d内存地址中

